---
title: "SampleProject_GLGameTool"
categories: [Project/Portfolio]
tag : ["OpenGL", "Project", "Graphics"]

---



# GLGameTooL

- 개발기간 : 2016.4 ~ 2016.9

- 개발환경 : OpenGL 3.2 + MFC

- 게임프로그래밍 입문하면서 만들었던 툴

- 기초적인 3D 게임 프로그래밍 공부를 위해 만들었습니다.

- [BaseLink](https://hns17.tistory.com/entry/GLGameTooL-3D-%ED%8F%AC%ED%8A%B8%ED%8F%B4%EB%A6%AC%EC%98%A4)



## **1. 모델 매니저**

- 모델 정보를 로드하며, 모델의 상태 및 모델 리스트를 보여줍니다.

- 모델 형식은 obj 파일과 ase파일을 사용합니다.

- ase의 경우 파서를 직접 만들었으며, obj의 경우 간단하게 분석하여 외부 파서를 조금 수정하여 사용하였습니다.

- 모델은 셋단위로 관리됩니다.

 

**[구성]**

![img](https://t1.daumcdn.net/cfile/tistory/998AF43F5B1B2C471C)

 

 

**[영상]**

<iframe src="https://www.youtube.com/embed/CHoqpaeVtpI?rel=0" frameborder="0" allowfullscreen=""></iframe>



###  **(1). ase**

- 게임 프로그래밍 공부를 해야겠다 결심하고, 가장 먼저 진행했던 것이 ASE 파서입니다.

- 당시 계층구조에 대한 개념이 전혀 없었고, 게임 프로그래밍도 처음 시작하는 단계라 꽤나 많은 시간이 걸렸던 것 같습니다.

 

[**파서를 만들면서 힘들었던 점을 정리해보면...**]

- vertex와 uv, normal의 갯수가 다르다는 점.

  - 모델링 파일 구조에 대한 지식이 없었고, 이전 3D 그래픽스 공부 할 때에는 지오메트리 모델을 알고리즘 등을 이용해 직접 만들어 사용하다 보니 항상 vertex와 uv, normal이 1:1 매칭이 되었습니다. 

  - uv, normal 정보에 맞춰 vertex를 추가 생성해야 한다는 사실을 모르고 있었기에 꽤 고생했던 것 같습니다.

* 애니메이션 행렬

  - 계층구조를 처음 접하면서 부모, 자식 간의 행렬 관계 및 키프레임 애니메이션을 이해하는데 중심을 뒀습니다. 

  - 우선 애니메이션을 제외한 모델링 파일을 렌더링하는데서 시작하여, 애니메이션 행렬을 업데이트하여 적용하는데 성공하였습니다.

- 스키닝 셰이더

  - 기본 ase 파일에는 스키닝 정보가 없기 때문에 max sdk에서 제공하는 ase exporter 프로젝트를 열어 스키닝 정보를 추가하여 빌드 후 스키닝 정보가 담긴 모델링 파일을 새로 추출하였습니다.
  - 파서에 스키닝 정보를 추가 후 가중치 값을 이용해 스키닝을 적용하는데 성공하였으나, 정작 셰이더에서 작업하는 것은 실패하였습니다. 
    - 시작은 cpu level에서 소프트웨어 스키닝 작업

  - 셰이더 모델 3.0 기준으로 가중치 정보가 셰이더에 한번에 전달 할 수 있는 범위를 넘어섰기 때문에 그래픽 장치가 다운되는 문제였습니다. 
    - 당시 사용중인 하드웨어가 SM 3.0 까지 밖에 지원못함 ㅜ
  - 이 당시 셰이더를 사용한지 얼마 되지 않았던 때라, 셰이더 코드에서 조명 정보를 구조체로 만들어 최대 8개까지 넘기고 있었기 때문에 가중치 정보를 포함하면 전달 가능한 최대 데이터 사이즈가 넘어버렸습니다.

 

## **2. 조명 매니저**

- 조명을 관리합니다.

- Directional, Position, Spot Light를 제공합니다. (기본은 Directional)

- 조명은 Set으로 관리되며 Set은 최대 8개의 조명을 가질 수 있습니다.

- 작업한 조명은 외부 파일로 추출하여 필요시 로드하여 사용 할 수 있습니다.

- 당시 메쉬당 라이팅이 어떻게 연산되는지, 디퍼드 렌더링에 대해서도 모르던 때라 그냥 되는대로 라이팅 정보를 전부 넘겼습니다... 

 

**[구성]**

![img](https://t1.daumcdn.net/cfile/tistory/996DE63E5B1B33E023)

 

**[영상]**

<iframe src="https://www.youtube.com/embed/ani1sSaj4BE?rel=0" frameborder="0" allowfullscreen=""></iframe>



 

 

## **3. 셰이더 매니저**

- 현재 로드된 셰이더 리스트와 상태를 보여줍니다.

- 셰이더 수정 및 교체가 용이합니다.

 

**[구성]**

![img](https://t1.daumcdn.net/cfile/tistory/99E15E3A5B1B36432A)

 

**[영상]**

<iframe src="https://www.youtube.com/embed/m_uYImvO-IQ?rel=0" frameborder="0" allowfullscreen=""></iframe>



 

###  **(1) 셰이더 이용 시 힘들었던 것과 지금 생각해보면 잘못되었던 것들...**

- Shader Model?
  - ShaderModel이 뭔지 몰랐으며, 전달 데이터 크기를 신경 써야하는지도 몰랐습니다.

- OpenGL 3.2, GLSL 150

  - OpenGL은 2.x 버젼을 클래식으로, 4.x 버젼을 모던으로 정의합니다.

  - 저는 3.2를 사용하였는데...(당시 사용하던 노트북이 3.2까지 지원.) OpenGL 3.2 버젼은 렌더링 방식이 Fixed 파이프라인에서 프로그래머블 파이프라인으로 완전 전환된 초기 버젼으로 사용상 불편한 것 들이 몇가지 있었습니다.

    - 예를 들면 셰이더 컴파일러나, glut 함수들...

    - ```
      glsl 150
      Sampler2D arr[3];
      arr[index] : 문제 생김,   arr[1] : 정상 동작
      
      GLSL400, OpenGL 4.0 부터 인덱스 접근 기능을 지원합니다.
      ```

- include 사용불가

  - 이 후 버젼은 모르겠지만, glsl 150은 include를 지원하지 않아 파서를 만들어야 했습니다.

- 잘못된 셰이더 지식
  - 당시 인터넷 튜토리얼 문서를 통해 셰이더를 공부하였는데, 대부분이 구버젼에서 이루어진 튜토리얼이라 실제 셰이더 작성시 지원되지 않는 키워드 및 구조체가 많았습니다. 
  - 또한 셰이더를 분류하는 이유를 생각하지 않았기에 셰이더 하나에 if 분기로 분류해 기능을 다 집어 넣고 작성.
  - 셰이더의 연결 레이아웃을 분리하지 않고 항상 전부 넘겼던 것도 문제.

 

## **4. 옥트리**

- 공간을 분할합니다.

- 옥트리의 크기는 참조하는 ModelSet에 위치한 모든 모델의 바운딩 박스를 참조하여 정해집니다.

- 옥트리의 공간은 커스텀 될 수 있으며, 노드 또한 추가 삭제 할 수 있어,   오브젝트의 배치에 맞춰 구성할 수 있습니다.

- 모델은 메쉬, 오브젝트, 모델 단위로 분류하여 노드에 할당 할 수 있습니다.

- 애니메이션이 있는 모델은 모델 단위로만 할당해야 합니다. (분할하면 애니메이션이 깨짐)

- 노드에 입력시 노드와 노드 사이에 겹치는 경우 상위노드에 할당됩니다.

 

**[구성]**

![img](https://t1.daumcdn.net/cfile/tistory/99B66C345B1E949B1D)

 

**[영상]**

<iframe src="https://www.youtube.com/embed/gdAHL6oT3_o?rel=0" frameborder="0" allowfullscreen=""></iframe>



 

## **5. 텍스쳐 매니저**

- 모델이 가지는 텍스쳐를 관리, 수정합니다.

- 오브젝트는 하나의 마테리얼을 가질 수 있으며, 마테리얼은 디퓨즈(디퓨즈, 마스크), 범프, 알파 텍스쳐를 가집니다. 

- 마테리얼에 사용되는 디퓨즈 텍스쳐는 최대4개 까지 추가하여 혼합 가능됩니다.

- 멀티 마테리얼은 지원하지 않습니다.

 

**[구성]**

![img](https://t1.daumcdn.net/cfile/tistory/9990DA425B1B3D761F)

 

**[영상]**

<iframe src="https://www.youtube.com/embed/RIpqFXt-VYM?rel=0" frameborder="0" allowfullscreen=""></iframe>



 

 

## **6. 사운드 매니저**

- 미구현

 

## **7. 지형 매니저**

- 하늘과 지형을 표현합니다.

- 지형은 QLOD 기반으로 행성을 만듭니다.

- 하늘은 AtmoSphere Scattering 셰이더를 이용해 렌더링 됩니다.

- 태양은 FrameBuffer와 blur 셰이더를 이용해 Lenz Flare로 표현합니다.

- 구름은 최대 4개의 레이어를 Lerp하여 표현합니다.

 

**[구성]**

![img](https://t1.daumcdn.net/cfile/tistory/994E2B3E5B1B43B62F)

 

**[영상]**

<iframe src="https://www.youtube.com/embed/iOVwG-l5Qfk?rel=0" frameborder="0" allowfullscreen=""></iframe>

 

###  **(1) QLOD를 이용한 Planet 생성 : [바로가기](http://hns17.tistory.com/entry/Procedural-Planet-Generate)**

- 절차기반 지형을 생성합니다.

 ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99F3F9445B053DBA07)



###  **(2) 하늘의 표현 (AtmoSphere Scattering)**

- 대기산란은 gpu gems2권의 내용을 참조하였습니다 : **[바로가기](https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html)**

- 참조 사이트에서 명시되지만 해당 셰이더는 **지면과 대기의 비율이 1.025로 고정**되며 조절이 힘들다는 문제를 가지고 있습니다.

- 많은 상수와 변수, 산란함수 등 처음 보는 내용이 많아 당시 상당히 애먹었던 것으로 기억합니다.

- LookUp table을 생성하여 ScaleFactor 정보를 가져오는 개선된 방법이 있다는 사실을 알게되었지만,  해당 프로젝트에서는 여기서 마무리 되었습니다.



| ![img](https://t1.daumcdn.net/cfile/tistory/99FB873C5B1A50F02C) | ![img](https://t1.daumcdn.net/cfile/tistory/9979A03C5B1A50F11E) | ![img](https://t1.daumcdn.net/cfile/tistory/99723A3C5B1A50F103) |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 대기의 레일리 산란 표현                                      | 렌즈 플레어로 태양 효과 표현                                 | 태양 중심 미 산란 표현                                       |



###  **(3) 구름의 표현**

- 처음에는 하늘과 구름을 큐브맵, 스카이 돔을 사용하였으나, 좀 더 괜찮은 방법을 찾다 아래 문서의 구름 렌더링 내용을 참고하여 만들게 되었습니다.

- 참고 : **[바로가기](https://www.slideshare.net/valhashi/2011-03-gametechtadptforpdf)**

- 구름을 레이어(층) 별로 나누어 생성한 후 회전을 적용 후 최종적으로 Lerp 하여 만듭니다.

 

###  **(4) 태양의 표현**

- 태양은 Lenz Flare 기법을 사용하였습니다.

- Sphere 모델을 블러 셰이더를 이용해 프레임 버퍼에 여러번 그립니다. 

- 만들어진 각각의 프레임버퍼와 Dirty Texture(디지털 캠에 얼룩 묻은 느낌?)를 혼합하여  최종 결과물을 만들어 냅니다.

 

 

##  **프로젝트를 진행하면서** 

###  **1. 얻게된 것**

- ase 파서를 만들면서 모델링 파일의 구조, 계층구조 및 키프레임 애니메이션에 대해 이해 할 수 있었습니다.

- 공간분할을 통한 컬링에 대해 알 수 있었습니다.

- 지형의 생성 및 Static Level of Detail을 구현하면서 절차적 지형 생성 방법을 이해 할 수 있었습니다.

 

###  **2. 아쉬운 점과 뒷 이야기**

- 프로젝트는 2016.4에 시작하여 ~ 2016.9월 말 까지 긴 기간 동안 진행되었습니다.

- 진행기간이 길어진 이유를 생각해보면, 처음 접하는 게임 이론이라는 이유도 있겠지만 역시 아르바이트가...

- 프로젝트가 더 진행되지는 않았지만, **이 후 진행한 것**을 적어보면...

  

####   **(1). 볼륨 렌더링**

- 구름을 어떻게 하면 사실적으로 표현 할 수 있을까? 고민하다가 알게된 기술.
  - Noise 함수와RayMarching 기술을 이용한 사실적인 구름 생성
    - 샘플링 량에 비례해 퀄리티는 상승하나 굉장히 느려진다.
    - 스크린 이펙트 방식으로 처리하기에 행성을 둘러싸는 구름과 층별 레이어를 표현하는 것은 어렵다.
    - 참고했던 사이트 : **[바로가기](https://www.shadertoy.com/view/XslGRr)**
  - MarchingCube와 Density Function 을 이용한 구름생성
    - RayMarching으로는 원하는 행성을 둘러싼 구름을 만들기 어렵다 판단하여, 다른 방법을 모색하다 알게된 기술.
    - 누군가 만들어둔 구름 모델링 파일이 있지 않을까? 에서 시작하여 절차적 구름 생성이 가능하다는 것을 알게 되었습니다. 밀도함수는 다행히 논문이 존재....

 

####   **(2) 임포스터**

- Marching Cube와 Density Funtion을 통해 특정 에리어를 구름으로 채우는 것은 성공하였으나...굉장히 느리다는 문제가 남았습니다.

- 해결 방법을 찾다가 임포스터에 대해 알게되었는데 확실히 효과가 있지만, 텍스쳐 렌더에서 모델 렌더로 전환 될 시 프리징이 심했습니다. 
  - 당시 해결 못하고 넘어 갔었던 기억이 있습니다.
- 참고문서 : Real-Time Cloud Rendering, Mark Harris

 

####  **(3) 유체역학**

- 유체역학 이론에 대해 알게된 계기는 역시 구름입니다.

- 볼륨 렌더링 기법을 통해 구름을 사실적으로 생성 할 수 있었지만, 전투기가 구름을 가로지르면 구름 모양이 변하는데 저건 어떻게 해야 될 까?에서 시작

- 사실 볼륨 렌더링 공부 할 때에도 엄청 어려웠지만... 역학 쪽으로 넘어가니, 수학적 한계가 찾아왔습니다.
  - SPH, Stable Fluid, Particle in Cell, FLIP... 단순 개념만 이해하려고 했으나, 그것도 정확하게 이해했는지는 잘 모르겠네요...

- 이 후 Nnvida의 물리 엔진을 찾아보게 되었는데, 유체를 크게 두 가지 액체와 기체로 나누어 액체 엔진(FLEX)에서는 PBF(PBD 기반 알고리즘이라는데 알아보지 않았습니다.), 기체 엔진 (FLOW) 에서는 GRID기반 (FLIP를 개선한 형태가 아닐까 추측합니다.) 으로 시뮬레이션 하는 것 같습니다.

 

####  **(4) 강체역학**

- 유체를 접하면서 강체 부터 제대로 공부해보자 해서 시작하게 되었습니다.

- 다행히 국내 참고 서적이 있어 쉽게 이해하고 접근 할 수 있었던 것 같습니다.

- 간단한 적분기를 만들어 시뮬레이션 해보면서 기본 강체의 움직임을 이해하고, 역학적 이론 및 용어를 이해하는데 도움이 된 것 같습니다.